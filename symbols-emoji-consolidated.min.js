(function(){'use strict'; let readQueue = []; let writeQueue = []; let scheduled = false; function flushQueues(){readQueue.forEach(fn => fn()); readQueue = []; writeQueue.forEach(fn => fn()); writeQueue = []; scheduled = false} function scheduleFlush(){if (!scheduled){scheduled = true; requestAnimationFrame(flushQueues)} } window.batchDOMRead = function(fn){readQueue.push(fn); scheduleFlush()}; window.batchDOMWrite = function(fn){writeQueue.push(fn); scheduleFlush()}; const layoutCache = new WeakMap(); window.getCachedLayout = function(element, property){if (!layoutCache.has(element)){layoutCache.set(element,{})} const cache = layoutCache.get(element); if (!(property in cache)){cache[property] = element[property]} return cache[property]}; window.addEventListener('resize', () =>{layoutCache.clear()})})(); (function (){'use strict'; (function blockAds(){try{Object.defineProperty(window, 'adsbygoogle',{value: [], writable: false, configurable: true }); Object.defineProperty(window, 'freestar',{value:{queue: [], config:{}, initCallback: function(){} }, writable: false, configurable: true })} catch (e){} function removeAdElements(root){var selectors = [ 'ins.adsbygoogle', '.ads', '.ads-sec', '.ad', '[data-freestar-ad]', '#coolsymbol-top_leaderboard_btf', '#coolsymbol-incontent_reusable' ]; try{selectors.forEach(function(sel){(root || document).querySelectorAll(sel).forEach(function(n){n.remove()})})} catch (e){} } removeAdElements(document); var blockedPatterns = [ /googlesyndication\.com/i, /a\.pub\.network|b\.pub\.network|c\.pub\.network|d\.pub\.network/i, /amazon-adsystem\.com/i, /btloader\.com|api\.btloader\.com/i, /confiant-integrations\.net/i, /pubfig\.min\.js|\/coolsymbol-top\/pubfig\.min\.js/i ]; var observer = new MutationObserver(function(mutations){mutations.forEach(function(m){Array.prototype.forEach.call(m.addedNodes || [], function(node){try{if (node && node.nodeType === 1){removeAdElements(node); if (node.tagName === 'SCRIPT'){var src = node.getAttribute('src') || ''; if (blockedPatterns.some(function(re){return re.test(src)})){node.remove()} } if (node.tagName === 'LINK'){var href = node.getAttribute('href') || ''; if (blockedPatterns.some(function(re){return re.test(href)})){node.remove()} } } } catch (e){} })})}); try{observer.observe(document.documentElement || document,{childList: true, subtree: true })} catch (e){} })(); function $(sel){return document.querySelector(sel)} function $all(sel){return Array.prototype.slice.call(document.querySelectorAll(sel))} async function writeToClipboard(text){if (navigator.clipboard && navigator.clipboard.writeText){try{await navigator.clipboard.writeText(text); return true} catch (e){console.warn('Clipboard API failed:', e)} } try{const ta = document.createElement('textarea'); ta.value = text; ta.setAttribute('readonly', ''); ta.style.position = 'fixed'; ta.style.left = '50%'; ta.style.top = '50%'; ta.style.transform = 'translate(-50%, -50%)'; ta.style.zIndex = '10000'; ta.style.background = 'white'; ta.style.border = '2px solid #230AC7'; ta.style.padding = '10px'; ta.style.borderRadius = '5px'; document.body.appendChild(ta); ta.focus(); ta.select(); ta.setSelectionRange(0, text.length); const instruction = document.createElement('div'); instruction.innerHTML = 'Press Ctrl+C (or Cmd+C on Mac) to copy'; instruction.style.position = 'fixed'; instruction.style.left = '50%'; instruction.style.top = 'calc(50% + 60px)'; instruction.style.transform = 'translateX(-50%)'; instruction.style.background = '#230AC7'; instruction.style.color = 'white'; instruction.style.padding = '5px 10px'; instruction.style.borderRadius = '3px'; instruction.style.zIndex = '10001'; instruction.style.fontSize = '14px'; document.body.appendChild(instruction); setTimeout(() =>{if (ta.parentNode) ta.parentNode.removeChild(ta); if (instruction.parentNode) instruction.parentNode.removeChild(instruction)}, 3000); return true} catch (e){console.error('Clipboard fallback failed:', e); return false} } const IDS ={symbolContainer: 'symbol-container', textbox: 'symbol-textbox' }; const STORAGE_KEYS ={symbols: 'symbols', textboxValue: 'textboxValue', snapshot: 'symbolsAndPage' }; window.addSymbolToContainer = function (text){const container = document.getElementById(IDS.symbolContainer); if (!container) return; const div = document.createElement('div'); div.classList.add('symbol'); div.textContent = text; div.addEventListener('click', function (ev){window.copyToClipboard(text, ev)}); container.insertBefore(div, container.firstChild || null); storeSymbols()}; window.addSymbolToTextbox = function (ev){const t = ev && ev.target; if (!t || !t.classList || !t.classList.contains('symbol')) return; const text = t.textContent || ''; const input = document.getElementById(IDS.textbox); if (!input) return; input.value += text; storeTextboxValue()}; window.clearStoredSymbols = function (){const container = document.getElementById(IDS.symbolContainer); if (container) container.textContent = ''; storeSymbols()}; window.clearTextbox = function (){const input = document.getElementById(IDS.textbox); if (input) input.value = ''; storeTextboxValue()}; window.copyAllToClipboard = async function (){const input = document.getElementById(IDS.textbox); if (!input) return; const text = input.value || ''; if (!text) return; await writeToClipboard(text); toast('Copied')}; window.copyToClipboard = async function (text, ev){await writeToClipboard(text); const container = document.getElementById(IDS.symbolContainer); if (container){const div = document.createElement('div'); div.className = 'message-anim'; div.textContent = text; container.insertBefore(div, container.firstChild || null); setTimeout(() =>{if (div.parentNode) div.parentNode.removeChild(div)}, 1500)} toast('Copy'); storeSymbols()}; function toast(msg){const el = document.createElement('div'); el.className = 'copy message'; el.innerText = msg; document.body.appendChild(el); setTimeout(() =>{if (el.parentNode) el.parentNode.removeChild(el)}, 1500)} window.storeSymbols = function (){const items = $all('#' + IDS.symbolContainer + ' .symbol').map(n => n.innerText); try{sessionStorage.setItem(STORAGE_KEYS.symbols, JSON.stringify(items))} catch (e){} }; window.setOutputFieldValue = function (){const container = document.getElementById(IDS.symbolContainer); if (!container) return; let items = []; try{items = JSON.parse(sessionStorage.getItem(STORAGE_KEYS.symbols)) || []} catch (e){items = []} items.forEach(txt =>{const d = document.createElement('div'); d.className = 'symbol'; d.innerText = txt; d.addEventListener('click', function (ev){window.copyToClipboard(txt, ev)}); container.appendChild(d)})}; window.storeTextboxValue = function (){const input = document.getElementById(IDS.textbox); if (!input) return; try{sessionStorage.setItem(STORAGE_KEYS.textboxValue, input.value || '')} catch (e){} }; window.setTextboxValue = function (){const input = document.getElementById(IDS.textbox); if (!input) return; const v = sessionStorage.getItem(STORAGE_KEYS.textboxValue) || ''; input.value = v}; window.onPageLoad = function (){let snap = null; try{snap = JSON.parse(sessionStorage.getItem(STORAGE_KEYS.snapshot)) || null} catch (e){snap = null} if (snap && snap.page === location.pathname){const container = document.getElementById(IDS.symbolContainer); if (container && Array.isArray(snap.symbols) && snap.symbols.length){snap.symbols.forEach(txt =>{const d = document.createElement('div'); d.className = 'symbol'; d.innerText = txt; d.addEventListener('click', function (ev){window.copyToClipboard(txt, ev)}); container.appendChild(d)})} const input = document.getElementById(IDS.textbox); if (input) input.value = snap.textboxValue || ''; try{sessionStorage.removeItem(STORAGE_KEYS.snapshot)} catch (e){} } }; function snapshotPage(){const container = document.getElementById(IDS.symbolContainer); const symbols = container ? $all('#' + IDS.symbolContainer + ' .symbol').map(n => n.innerText) : []; const textbox = document.getElementById(IDS.textbox); const textboxValue = textbox ? textbox.value : ''; const snap ={symbols, textboxValue, page: location.pathname }; try{sessionStorage.setItem(STORAGE_KEYS.snapshot, JSON.stringify(snap))} catch (e){} } function ensureScript(src, check){return new Promise((resolve) =>{if (check && check()) return resolve(true); const s = document.createElement('script'); s.src = src; s.async = true; s.onload = () => resolve(true); s.onerror = () => resolve(false); document.head.appendChild(s)})} async function ensureDependencies(){await ensureScript('https: await ensureScript('https: } function initInfiniteScroll(){if (!window.jQuery || !(jQuery.fn && jQuery.fn.infiniteScroll)) return; const $container = jQuery('.maindata'); if (!$container.length) return; $container.infiniteScroll({path: '.page-next', append: '.symbol', history: 'push', status: '.page-load-status' }).on('request.infiniteScroll', snapshotPage)} document.addEventListener('DOMContentLoaded', async function (){setOutputFieldValue(); setTextboxValue(); onPageLoad(); await ensureDependencies(); initInfiniteScroll()})})(); (function(){'use strict'; const blockedDomains = [ 'pub.network', 'a.pub.network', 'b.pub.network', 'c.pub.network', 'd.pub.network', 'googlesyndication.com', 'amazon-adsystem.com', 'btloader.com', 'confiant-integrations.net' ]; const blockedScripts = [ 'prebid.js', 'pubfig.engine.mobile.js', 'pubfig.min.js', 'adsbygoogle.js', 'amazon-adsystem.com' ]; const originalFetch = window.fetch; window.fetch = function(...args){const url = args[0]; if (typeof url === 'string'){for (const domain of blockedDomains){if (url.includes(domain)){console.log('🚫 Blocked ad request:', url); return Promise.reject(new Error('Blocked by ad blocker'))} } } return originalFetch.apply(this, args)}; const originalOpen = XMLHttpRequest.prototype.open; XMLHttpRequest.prototype.open = function(method, url, ...args){if (typeof url === 'string'){for (const domain of blockedDomains){if (url.includes(domain)){console.log('🚫 Blocked XHR ad request:', url); return} } } return originalOpen.call(this, method, url, ...args)}; const originalCreateElement = document.createElement; document.createElement = function(tagName){const element = originalCreateElement.call(this, tagName); if (tagName.toLowerCase() === 'script'){const originalSetAttribute = element.setAttribute; element.setAttribute = function(name, value){if (name === 'src' && typeof value === 'string'){for (const domain of blockedDomains){if (value.includes(domain)){console.log('🚫 Blocked script load:', value); return} } for (const script of blockedScripts){if (value.includes(script)){console.log('🚫 Blocked script load:', value); return} } } return originalSetAttribute.call(this, name, value)}} return element}; function removeAdElements(){const adSelectors = [ 'script[src*="pub.network"]', 'script[src*="googlesyndication"]', 'script[src*="amazon-adsystem"]', 'script[src*="prebid.js"]', 'script[src*="pubfig"]', 'link[href*="pub.network"]', 'ins.adsbygoogle', '.ads', '.ad', '[data-ad-client]', '[data-freestar-ad]' ]; adSelectors.forEach(selector =>{document.querySelectorAll(selector).forEach(element =>{console.log('🚫 Removed ad element:', selector); element.remove()})})} removeAdElements(); const observer = new MutationObserver(function(mutations){mutations.forEach(function(mutation){mutation.addedNodes.forEach(function(node){if (node.nodeType === 1){if (node.tagName === 'SCRIPT'){const src = node.getAttribute('src') || ''; for (const domain of blockedDomains){if (src.includes(domain)){console.log('🚫 Blocked dynamic script:', src); node.remove(); return} } } const adElements = node.querySelectorAll && node.querySelectorAll('script[src*="pub.network"], script[src*="googlesyndication"], ins.adsbygoogle'); if (adElements){adElements.forEach(el =>{console.log('🚫 Removed dynamic ad element'); el.remove()})} } })})}); observer.observe(document.documentElement,{childList: true, subtree: true }); Object.defineProperty(window, 'adsbygoogle',{value: [], writable: false, configurable: false }); Object.defineProperty(window, 'googletag',{value:{cmd: [], pubads: () => ({}) }, writable: false, configurable: false }); console.log('🛡️ Advanced ad blocker activated - pub.network and other ads blocked')})(); (function(){'use strict'; const imageObserver = new IntersectionObserver((entries, observer) =>{entries.forEach(entry =>{if (entry.isIntersecting){const img = entry.target; if (img.dataset.src){img.src = img.dataset.src; img.removeAttribute('data-src')} if (img.dataset.srcset){img.srcset = img.dataset.srcset; img.removeAttribute('data-srcset')} img.classList.remove('lazy'); observer.unobserve(img)} })},{rootMargin: '50px 0px', threshold: 0.01 }); const contentObserver = new IntersectionObserver((entries, observer) =>{entries.forEach(entry =>{if (entry.isIntersecting){const element = entry.target; if (element.dataset.content){element.innerHTML = element.dataset.content; element.removeAttribute('data-content')} element.classList.remove('lazy-content'); observer.unobserve(element)} })},{rootMargin: '100px 0px', threshold: 0.01 }); function initLazyLoading(){document.querySelectorAll('img[data-src]').forEach(img =>{imageObserver.observe(img)}); document.querySelectorAll('.lazy-content').forEach(element =>{contentObserver.observe(element)})} function injectCriticalCSS(){const criticalCSS = ` .lazy{opacity: 0; transition: opacity 0.3s} .lazy.loaded{opacity: 1} .lazy-content{min-height: 50px; background: #f5f5f5} .symbol{contain: layout style paint} .mainlogo img{contain: layout} `; const style = document.createElement('style'); style.textContent = criticalCSS; document.head.appendChild(style)} function preloadCriticalResources(){const preloadLinks = [{href: 'img/symbolsemoji.webp', as: 'image' },{href: 'main.min.css', as: 'style' } ]; preloadLinks.forEach(link =>{const linkEl = document.createElement('link'); linkEl.rel = 'preload'; linkEl.href = link.href; linkEl.as = link.as; document.head.appendChild(linkEl)})} if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () =>{injectCriticalCSS(); initLazyLoading(); preloadCriticalResources()})} else{injectCriticalCSS(); initLazyLoading(); preloadCriticalResources()} })(); (function(){'use strict'; function breakUpLongTasks(){const tasks = []; let taskIndex = 0; function scheduleTask(fn, priority = 'background'){if ('scheduler' in window && 'postTask' in scheduler){return scheduler.postTask(fn,{priority })} else{return new Promise(resolve =>{setTimeout(() => resolve(fn()), 0)})} } const scripts = document.querySelectorAll('script[data-defer="true"]'); scripts.forEach(script =>{scheduleTask(() =>{const newScript = document.createElement('script'); newScript.src = script.src; newScript.async = true; document.head.appendChild(newScript)}, 'background')})} function optimizeFCP(){const fontPreload = document.createElement('link'); fontPreload.rel = 'preload'; fontPreload.href = 'https: fontPreload.as = 'style'; fontPreload.crossOrigin = 'anonymous'; document.head.insertBefore(fontPreload, document.head.firstChild); const criticalCSS = document.querySelector('style'); if (criticalCSS){criticalCSS.textContent += ` body{font-display: swap} .mainlogo img{content-visibility: auto; contain-intrinsic-size: 270px 50px} .symbol{content-visibility: auto; contain-intrinsic-size: 50px 50px} `} } function optimizeLCP(){const lcpImage = document.querySelector('.mainlogo img'); if (lcpImage && lcpImage.src){const preloadLink = document.createElement('link'); preloadLink.rel = 'preload'; preloadLink.href = lcpImage.src; preloadLink.as = 'image'; document.head.appendChild(preloadLink)} const images = document.querySelectorAll('img'); images.forEach((img, index) =>{if (index < 3){img.loading = 'eager'; img.decoding = 'sync'} else{img.loading = 'lazy'; img.decoding = 'async'} })} function fixCLS(){const images = document.querySelectorAll('img:not([width]):not([height])'); images.forEach(img =>{if (img.classList.contains('mainlogo')){img.width = 270; img.height = 50} else{img.width = 50; img.height = 50} img.style.aspectRatio = `${img.width}/${img.height}`}); const dynamicElements = document.querySelectorAll('.symbol'); dynamicElements.forEach(el =>{el.style.minHeight = '50px'; el.style.minWidth = '50px'}); document.fonts.ready.then(() =>{document.body.classList.add('fonts-loaded')})} function optimizeSpeedIndex(){const symbolContainer = document.querySelector('.maindata'); if (symbolContainer){symbolContainer.innerHTML = ` <div class="skeleton-loader"> ${Array(20).fill('<div class="skeleton-symbol"></div>').join('')} </div> `; scheduleTask(() =>{loadSymbolsProgressively()}, 'user-visible')} } function loadSymbolsProgressively(){const symbolData = window.symbolData || []; const container = document.querySelector('.maindata'); const fragment = document.createDocumentFragment(); let index = 0; function loadChunk(){const chunk = symbolData.slice(index, index + 10); chunk.forEach(symbol =>{const div = document.createElement('div'); div.className = 'symbol'; div.textContent = symbol.char; div.title = symbol.name; fragment.appendChild(div)}); container.appendChild(fragment); index += 10; if (index < symbolData.length){scheduleTask(loadChunk, 'background')} } loadChunk()} function optimizeResources(){const scripts = document.querySelectorAll('script[src]'); scripts.forEach(script =>{if (!script.async && !script.defer){script.defer = true} }); const stylesheets = document.querySelectorAll('link[rel="stylesheet"]'); stylesheets.forEach(link =>{if (!link.media || link.media === 'all'){link.media = 'print'; link.onload = function(){this.media = 'all'; this.onload = null}} })} function monitorPerformance(){if ('PerformanceObserver' in window){const lcpObserver = new PerformanceObserver((list) =>{const entries = list.getEntries(); const lastEntry = entries[entries.length - 1]; console.log('LCP:', lastEntry.startTime)}); lcpObserver.observe({entryTypes: ['largest-contentful-paint'] }); const clsObserver = new PerformanceObserver((list) =>{let clsValue = 0; for (const entry of list.getEntries()){if (!entry.hadRecentInput){clsValue += entry.value} } console.log('CLS:', clsValue)}); clsObserver.observe({entryTypes: ['layout-shift'] }); const fidObserver = new PerformanceObserver((list) =>{for (const entry of list.getEntries()){console.log('FID:', entry.processingStart - entry.startTime)} }); fidObserver.observe({entryTypes: ['first-input'] })} } function init(){optimizeFCP(); fixCLS(); if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () =>{optimizeLCP(); breakUpLongTasks(); optimizeSpeedIndex(); optimizeResources(); monitorPerformance()})} else{optimizeLCP(); breakUpLongTasks(); optimizeSpeedIndex(); optimizeResources(); monitorPerformance()} } function scheduleTask(fn, priority = 'background'){if ('scheduler' in window && 'postTask' in scheduler){return scheduler.postTask(fn,{priority })} else{return new Promise(resolve =>{setTimeout(() => resolve(fn()), 0)})} } init()})(); const skeletonCSS = document.createElement('style'); skeletonCSS.textContent = ` .skeleton-loader{display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 1rem} .skeleton-symbol{width: 50px; height: 50px; background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; border-radius: 5px} @keyframes shimmer{0%{background-position: 200% 0} 100%{background-position: -200% 0} } .fonts-loaded{font-display: swap} `; document.head.appendChild(skeletonCSS); (function(){'use strict'; class LayoutShiftPrevention{constructor(){this.observer = null; this.styleCache = new Map(); this.dimensionCache = new Map(); this.init()} init(){this.applyImmediateFixes(); if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () => this.setupAfterDOM())} else{this.setupAfterDOM()} } applyImmediateFixes(){const criticalCSS = ` <style id="layout-stability-critical"> *{box-sizing: border-box !important} img:not([width]):not([height]){min-height: 50px; background: #f0f0f0} body{font-display: swap; text-rendering: optimizeSpeed} .symbol{min-width: 50px !important; min-height: 50px !important; display: inline-block !important; vertical-align: top !important; contain: layout style paint !important} header{min-height: 60px; contain: layout style paint} .mainlogo{min-height: 50px; contain: layout style paint} .maindata{min-height: 200px; contain: layout style paint} .footer{min-height: 80px; contain: layout style paint} .css-loading *{transition: none !important; animation: none !important} .async-content{min-height: 100px; background: transparent} </style> `; document.head.insertAdjacentHTML('afterbegin', criticalCSS); document.documentElement.classList.add('css-loading')} setupAfterDOM(){this.waitForCSS().then(() =>{document.documentElement.classList.remove('css-loading')}); this.preserveImageDimensions(); this.optimizeFontLoading(); this.stabilizeDynamicContent(); this.setupResizeHandling()} async waitForCSS(){const cssLinks = document.querySelectorAll('link[rel="stylesheet"], link[rel="preload"][as="style"]'); const promises = Array.from(cssLinks).map(link =>{return new Promise(resolve =>{if (link.sheet){resolve()} else{link.addEventListener('load', resolve); link.addEventListener('error', resolve); setTimeout(resolve, 3000)} })}); await Promise.all(promises); return new Promise(resolve => setTimeout(resolve, 100))} preserveImageDimensions(){const images = document.querySelectorAll('img'); images.forEach(img =>{if (!img.width || !img.height){if (img.src.includes('logo') || img.classList.contains('logo')){img.style.width = '270px'; img.style.height = '50px'} else{img.style.minWidth = '50px'; img.style.minHeight = '50px'} } img.style.contain = 'layout style paint'})} optimizeFontLoading(){const fontPreloads = [{family: 'Arial', weight: 'normal' },{family: 'Segoe UI', weight: 'normal' } ]; fontPreloads.forEach(font =>{const link = document.createElement('link'); link.rel = 'preload'; link.as = 'font'; link.type = 'font/woff2'; link.crossOrigin = 'anonymous'; document.head.appendChild(link)}); const style = document.createElement('style'); style.textContent = ` @font-face{font-display: swap} *{font-display: swap !important} `; document.head.appendChild(style)} stabilizeDynamicContent(){const symbolContainers = document.querySelectorAll('.maindata, .symbol, .container'); symbolContainers.forEach(container =>{if (!container.style.minHeight){container.style.minHeight = container.offsetHeight + 'px'} container.style.contain = 'layout style paint'}); this.observer = new MutationObserver(mutations =>{mutations.forEach(mutation =>{if (mutation.type === 'childList'){mutation.addedNodes.forEach(node =>{if (node.nodeType === 1){this.stabilizeElement(node)} })} })}); this.observer.observe(document.body,{childList: true, subtree: true })} stabilizeElement(element){if (element.classList.contains('symbol')){element.style.minWidth = '50px'; element.style.minHeight = '50px'; element.style.contain = 'layout style paint'} if (element.tagName === 'IMG'){element.style.contain = 'layout style paint'} } setupResizeHandling(){let resizeTimeout; window.addEventListener('resize', () =>{clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() =>{this.dimensionCache.clear(); this.updateDimensions()}, 150)},{passive: true })} updateDimensions(){const elements = document.querySelectorAll('.symbol, .maindata, header, .footer'); elements.forEach(el =>{const rect = el.getBoundingClientRect(); this.dimensionCache.set(el,{width: rect.width, height: rect.height })})} destroy(){if (this.observer){this.observer.disconnect()} } } new LayoutShiftPrevention(); let ticking = false; function updateScrollPosition(){ticking = false} window.addEventListener('scroll', () =>{if (!ticking){requestAnimationFrame(updateScrollPosition); ticking = true} },{passive: true }); document.addEventListener('click', (e) =>{if (e.target.classList.contains('symbol')){e.target.style.transform = 'translateY(-2px)'; setTimeout(() =>{e.target.style.transform = ''}, 150)} }); const style = document.createElement('style'); style.textContent = ` .symbol:hover{transform: translateY(-5px) !important; margin-top: 0 !important; will-change: transform} .symbol{will-change: transform; backface-visibility: hidden; transform: translateZ(0)} `; document.head.appendChild(style)})(); (function(){'use strict'; const optimizeImages = () =>{const images = document.querySelectorAll('img'); images.forEach(img =>{if (img.closest('.mainlogo')){img.width = 270; img.height = 50; img.style.cssText = 'width:270px;height:50px;aspect-ratio:270/50;display:block;margin:0 auto'} else if (!img.width || !img.height){img.width = 50; img.height = 50; img.style.cssText = 'width:50px;height:50px;aspect-ratio:1/1'} img.loading = img.closest('.mainlogo') ? 'eager' : 'lazy'; img.decoding = 'async'; img.style.imageRendering = 'optimizeSpeed'; img.onerror = function(){this.style.display = 'none'}})}; const convertToWebP = () =>{const images = document.querySelectorAll('img[src$=".png"], img[src$=".jpg"], img[src$=".jpeg"]'); images.forEach(img =>{const webpSrc = img.src.replace(/\.(png|jpg|jpeg)$/i, '.webp'); const webpTest = new Image(); webpTest.onload = function(){if (this.width > 0 && this.height > 0){img.src = webpSrc} }; webpTest.src = webpSrc})}; const progressiveImageLoad = () =>{if ('IntersectionObserver' in window){const imageObserver = new IntersectionObserver((entries) =>{entries.forEach(entry =>{if (entry.isIntersecting){const img = entry.target; if (img.dataset.src){img.src = img.dataset.src; img.removeAttribute('data-src')} img.style.opacity = '0'; img.style.transition = 'opacity 0.3s'; img.onload = function(){this.style.opacity = '1'}; imageObserver.unobserve(img)} })},{rootMargin: '50px' }); document.querySelectorAll('img[data-src]').forEach(img =>{imageObserver.observe(img)})} }; const preloadCriticalImages = () =>{const criticalImages = [ 'img/symbolsemoji.com.webp', 'img/favicon-96x96.png' ]; criticalImages.forEach(src =>{const link = document.createElement('link'); link.rel = 'preload'; link.as = 'image'; link.href = src; link.importance = 'high'; document.head.appendChild(link)})}; const addResponsiveImages = () =>{const images = document.querySelectorAll('img'); images.forEach(img =>{if (!img.srcset && !img.closest('.mainlogo')){const baseSrc = img.src.replace(/\.(png|jpg|jpeg|webp)$/i, ''); const ext = img.src.match(/\.(png|jpg|jpeg|webp)$/i)?.[0] || '.webp'; img.srcset = ` ${baseSrc}-small${ext} 480w, ${baseSrc}-medium${ext} 768w, ${baseSrc}${ext} 1200w `.trim(); img.sizes = '(max-width: 480px) 100vw, (max-width: 768px) 50vw, 25vw'} })}; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () =>{optimizeImages(); preloadCriticalImages(); convertToWebP(); progressiveImageLoad(); addResponsiveImages()})} else{optimizeImages(); preloadCriticalImages(); convertToWebP(); progressiveImageLoad(); addResponsiveImages()} })(); const CACHE_VERSION = 'v1'; const STATIC_CACHE = `static-${CACHE_VERSION}`; const DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`; const IMAGE_CACHE = `images-${CACHE_VERSION}`; const STATIC_ASSETS = [ '/', '/index.html', '/main.css', '/main.min.css', '/critical-performance-fix.js', '/ultra-performance-optimizer.js', '/image-optimizer.js', '/caching-strategy.js' ]; const IMAGE_ASSETS = [ '/img/symbolsemoji.com.webp', '/img/favicon-96x96.png', '/img/apple-touch-icon.png' ]; self.addEventListener('install', event =>{event.waitUntil( Promise.all([ caches.open(STATIC_CACHE).then(cache => cache.addAll(STATIC_ASSETS)), caches.open(IMAGE_CACHE).then(cache => cache.addAll(IMAGE_ASSETS)) ]) ); self.skipWaiting()}); self.addEventListener('activate', event =>{event.waitUntil( caches.keys().then(cacheNames =>{return Promise.all( cacheNames.map(cacheName =>{if (!cacheName.includes(CACHE_VERSION)){return caches.delete(cacheName)} }) )}) ); self.clients.claim()}); self.addEventListener('fetch', event =>{const{request } = event; const url = new URL(request.url); if (request.method !== 'GET') return; if (request.destination === 'image'){event.respondWith(cacheFirst(request, IMAGE_CACHE))} else if (request.destination === 'style' || request.destination === 'script'){event.respondWith(staleWhileRevalidate(request, DYNAMIC_CACHE))} else if (request.destination === 'document'){event.respondWith(networkFirst(request, DYNAMIC_CACHE))} else{event.respondWith(cacheFirst(request, STATIC_CACHE))} }); async function cacheFirst(request, cacheName){const cache = await caches.open(cacheName); const cached = await cache.match(request); if (cached){return cached} try{const response = await fetch(request); if (response.status === 200){cache.put(request, response.clone())} return response} catch (error){return new Response('Offline',{status: 503 })} } async function networkFirst(request, cacheName){const cache = await caches.open(cacheName); try{const response = await fetch(request); if (response.status === 200){cache.put(request, response.clone())} return response} catch (error){const cached = await cache.match(request); return cached || new Response('Offline',{status: 503 })} } async function staleWhileRevalidate(request, cacheName){const cache = await caches.open(cacheName); const cached = await cache.match(request); const fetchPromise = fetch(request).then(response =>{if (response.status === 200){cache.put(request, response.clone())} return response}).catch(() => cached); return cached || fetchPromise} (function(){'use strict'; const taskQueue = []; let isProcessing = false; function scheduleTask(fn, priority = 'background'){if ('scheduler' in window && 'postTask' in scheduler){return scheduler.postTask(fn,{priority })} taskQueue.push(fn); if (!isProcessing){processTaskQueue()} } function processTaskQueue(){isProcessing = true; const startTime = performance.now(); while (taskQueue.length > 0 && (performance.now() - startTime) < 5){const task = taskQueue.shift(); try{task()} catch (e){console.warn('Task error:', e)} } isProcessing = false; if (taskQueue.length > 0){setTimeout(processTaskQueue, 0)} } const criticalResources = [{href: 'main.css', as: 'style' },{href: 'main.min.css', as: 'style' } ]; criticalResources.forEach(resource =>{const link = document.createElement('link'); link.rel = 'preload'; link.href = resource.href; link.as = resource.as; link.crossOrigin = 'anonymous'; document.head.appendChild(link)}); const logoImg = document.querySelector('.mainlogo img'); if (logoImg && logoImg.src){const preloadLink = document.createElement('link'); preloadLink.rel = 'preload'; preloadLink.href = logoImg.src; preloadLink.as = 'image'; document.head.appendChild(preloadLink)} function stabilizeElements(){const logoImages = document.querySelectorAll('.mainlogo img'); logoImages.forEach(img =>{if (!img.style.width) img.style.width = '270px'; if (!img.style.height) img.style.height = '50px'; img.style.aspectRatio = '270/50'}); const symbols = document.querySelectorAll('.symbol'); symbols.forEach(symbol =>{if (!symbol.style.width) symbol.style.width = '50px'; if (!symbol.style.height) symbol.style.height = '50px'; symbol.style.aspectRatio = '1/1'}); const maindata = document.querySelector('.maindata'); if (maindata && !maindata.style.minHeight){maindata.style.minHeight = '200px'} } function optimizeRendering(){const symbols = document.querySelectorAll('.symbol'); symbols.forEach((symbol, index) =>{if (index > 20){symbol.style.contentVisibility = 'auto'; symbol.style.containIntrinsicSize = '50px 50px'} }); const images = document.querySelectorAll('img'); images.forEach((img, index) =>{if (index < 3){img.loading = 'eager'; img.decoding = 'sync'} else{img.loading = 'lazy'; img.decoding = 'async'} })} const heavyScripts = [ 'script-phphp.js', 'script-phphp8a5c.js', 'performance-audit.js', 'treemap-analyzer.js', 'dom-optimizer.js' ]; function deferHeavyScripts(){heavyScripts.forEach(scriptName =>{const script = document.querySelector(`script[src*="${scriptName}"]`); if (script){script.defer = true; script.async = true} })} function optimizeEvents(){const maindata = document.querySelector('.maindata'); if (maindata){maindata.addEventListener('click', function(e){if (e.target.classList.contains('symbol')){scheduleTask(() =>{const text = e.target.textContent; if (window.copyToClipboard){window.copyToClipboard(text, e)} }, 'user-blocking')} },{passive: false })} } function optimizeFonts(){const style = document.createElement('style'); style.textContent = ` @font-face{font-family: 'Arial'; font-display: swap; src: local('Arial')} body, .symbol, .mainlogo{font-family: Arial, -apple-system, BlinkMacSystemFont, sans-serif} `; document.head.appendChild(style)} function addResourceHints(){const hints = [{rel: 'dns-prefetch', href: '{rel: 'preconnect', href: 'https: ]; hints.forEach(hint =>{const link = document.createElement('link'); link.rel = hint.rel; link.href = hint.href; if (hint.crossorigin) link.crossOrigin = hint.crossorigin; document.head.appendChild(link)})} function monitorPerformance(){if ('PerformanceObserver' in window){const observer = new PerformanceObserver((list) =>{for (const entry of list.getEntries()){if (entry.entryType === 'largest-contentful-paint'){console.log('LCP:', entry.startTime)} if (entry.entryType === 'layout-shift' && !entry.hadRecentInput){console.log('CLS:', entry.value)} if (entry.entryType === 'first-input'){console.log('FID:', entry.processingStart - entry.startTime)} } }); try{observer.observe({entryTypes: ['largest-contentful-paint', 'layout-shift', 'first-input'] })} catch (e){console.warn('Performance observer not supported')} } } function init(){stabilizeElements(); optimizeFonts(); addResourceHints(); deferHeavyScripts(); if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () =>{scheduleTask(optimizeRendering); scheduleTask(optimizeEvents); scheduleTask(monitorPerformance)})} else{scheduleTask(optimizeRendering); scheduleTask(optimizeEvents); scheduleTask(monitorPerformance)} } init(); window.scheduleTask = scheduleTask})(); (function(){'use strict'; function fixImageLayoutShifts(){const images = document.querySelectorAll('img'); images.forEach(img =>{if (!img.width && !img.height){if (img.classList.contains('mainlogo') || img.closest('.mainlogo')){img.width = 270; img.height = 50; img.style.aspectRatio = '270/50'} else{img.width = 50; img.height = 50; img.style.aspectRatio = '1/1'} } if (!img.complete){img.style.backgroundColor = '#f0f0f0'; img.style.minHeight = img.height + 'px'; img.style.minWidth = img.width + 'px'} img.addEventListener('load', function(){this.style.backgroundColor = 'transparent'},{once: true }); img.addEventListener('error', function(){this.style.backgroundColor = '#ffebee'; this.alt = 'Image failed to load'},{once: true })})} function reserveSpaceForDynamicContent(){const symbolContainers = document.querySelectorAll('.maindata, .symbol-container'); symbolContainers.forEach(container =>{if (!container.style.minHeight){container.style.minHeight = '200px'} }); const symbols = document.querySelectorAll('.symbol'); symbols.forEach(symbol =>{symbol.style.width = '50px'; symbol.style.height = '50px'; symbol.style.minWidth = '50px'; symbol.style.minHeight = '50px'; symbol.style.flexShrink = '0'}); const footer = document.querySelector('.footer, footer'); if (footer && !footer.style.minHeight){footer.style.minHeight = '80px'} } function stabilizeFontLoading(){const style = document.createElement('style'); style.textContent = ` @font-face{font-family: 'Arial'; font-display: swap; src: local('Arial'), local('Arial Regular')} body, .symbol, .mainlogo{font-family: Arial, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif} `; document.head.appendChild(style); if (document.fonts && document.fonts.ready){document.fonts.ready.then(() =>{document.body.classList.add('fonts-loaded')})} } function preventThirdPartyShifts(){const adContainers = document.querySelectorAll('[id*="ad"], [class*="ad"], .advertisement'); adContainers.forEach(container =>{if (!container.style.minHeight){container.style.minHeight = '250px'; container.style.backgroundColor = '#f9f9f9'; container.style.border = '1px solid #e0e0e0'} }); const observer = new MutationObserver(mutations =>{mutations.forEach(mutation =>{mutation.addedNodes.forEach(node =>{if (node.nodeType === Node.ELEMENT_NODE){if (node.tagName === 'SCRIPT' && node.src && (node.src.includes('googletagmanager') || node.src.includes('google-analytics') || node.src.includes('doubleclick'))){node.async = true; node.defer = true} } })})}); observer.observe(document.head,{childList: true })} function stabilizeDynamicContent(){const belowFoldElements = document.querySelectorAll('.symbol'); belowFoldElements.forEach((element, index) =>{if (index > 20){element.style.contentVisibility = 'auto'; element.style.containIntrinsicSize = '50px 50px'} }); const dynamicContainers = document.querySelectorAll('[data-dynamic="true"]'); dynamicContainers.forEach(container =>{if (!container.innerHTML.trim()){container.innerHTML = '<div class="skeleton-placeholder"></div>'; container.style.minHeight = '50px'} })} function monitorLayoutShifts(){if ('PerformanceObserver' in window){let clsValue = 0; let clsEntries = []; const observer = new PerformanceObserver((list) =>{for (const entry of list.getEntries()){if (!entry.hadRecentInput){clsValue += entry.value; clsEntries.push(entry); if (entry.value > 0.1){console.warn('Large layout shift detected:',{value: entry.value, sources: entry.sources, startTime: entry.startTime })} } } if (clsValue > 0){console.log('Cumulative Layout Shift:', clsValue.toFixed(4))} }); observer.observe({entryTypes: ['layout-shift'] }); window.addEventListener('beforeunload', () =>{console.log('Final CLS Score:', clsValue.toFixed(4))})} } function fixCommonShiftCauses(){const images = document.querySelectorAll('img:not([alt])'); images.forEach(img =>{img.alt = img.title || 'Symbol'}); const hoverElements = document.querySelectorAll('.symbol'); hoverElements.forEach(element =>{element.addEventListener('mouseenter', function(){this.style.transform = 'translateY(-5px)'}); element.addEventListener('mouseleave', function(){this.style.transform = 'translateY(0)'})}); document.head.insertAdjacentHTML('beforeend', ` <style> .font-loading body{visibility: hidden} .font-loaded body{visibility: visible} </style> `)} function ensureResponsiveStability(){const responsiveCSS = document.createElement('style'); responsiveCSS.textContent = ` .maindata{display: flex; flex-wrap: wrap; gap: 0.5rem; align-content: flex-start; min-height: 200px} .symbol{flex: 0 0 50px; height: 50px; box-sizing: border-box} @media (max-width: 768px){.symbol{flex: 0 0 45px; height: 45px; font-size: 18px; line-height: 45px} } @media (max-width: 480px){.symbol{flex: 0 0 40px; height: 40px; font-size: 16px; line-height: 40px} } `; document.head.appendChild(responsiveCSS)} function init(){fixImageLayoutShifts(); reserveSpaceForDynamicContent(); stabilizeFontLoading(); if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', () =>{preventThirdPartyShifts(); stabilizeDynamicContent(); fixCommonShiftCauses(); ensureResponsiveStability(); monitorLayoutShifts()})} else{preventThirdPartyShifts(); stabilizeDynamicContent(); fixCommonShiftCauses(); ensureResponsiveStability(); monitorLayoutShifts()} } init()})(); const fs = require('fs'); const path = require('path'); function optimizeImageCompression(){console.log('Image compression optimization for symbolsemoji.webp'); console.log('Current size: 7.3KB, Target: ~1.5KB (79% reduction)'); const optimizationScript = ` # Image Compression Optimization Guide ## Current Issue: - File: /img/symbolsemoji.webp - Current size: 7.3KB - Potential savings: 5.8KB (79% reduction) - Target size: ~1.5KB ## Optimization Methods: ### Method 1: Online WebP Compressor 1. Visit: https: 2. Upload: img/symbolsemoji.webp 3. Adjust quality to 60-70% for logos 4. Download optimized version 5. Replace original file ### Method 2: Command Line (if available) \`\`\`bash # Using cwebp (WebP encoder) cwebp -q 65 img/symbolsemoji.webp -o img/symbolsemoji-optimized.webp # Using ImageMagick magick img/symbolsemoji.webp -quality 65 img/symbolsemoji-optimized.webp \`\`\` ### Method 3: CSS Optimization (Immediate) Since this is a logo, we can also optimize how it's used: `; const cssOptimization = ` .mainlogo img{width: 270px; height: 54px; background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading 1.5s infinite; image-rendering: optimizeQuality; image-rendering: -webkit-optimize-contrast} @keyframes loading{0%{background-position: 200% 0} 100%{background-position: -200% 0} } .mainlogo img[src]{animation: none; background: none} @media (min-width: 768px){.mainlogo::before{content: ''; display: none; background-image: url('img/symbolsemoji.webp')} } `; fs.writeFileSync('image-optimization-guide.md', optimizationScript); fs.writeFileSync('logo-optimization.css', cssOptimization); console.log('Created optimization files:'); console.log('- image-optimization-guide.md: Manual compression instructions'); console.log('- logo-optimization.css: CSS optimizations for immediate improvement'); const htmlOptimization = ` <!-- Optimized image loading with fallbacks --> <picture> <source srcset="img/symbolsemoji-optimized.webp" type="image/webp"> <source srcset="img/symbolsemoji-optimized.png" type="image/png"> <img alt="CoolSymbol logo" width="270" height="54" loading="eager" decoding="async" src="img/symbolsemoji.webp" style="image-rendering: optimizeQuality;"> </picture> `; console.log('\nRecommended HTML structure for optimized loading:'); console.log(htmlOptimization); return true} function createOptimizedImagePlaceholder(){const svgLogo = `<svg width="270" height="54" xmlns="http: <defs> <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="0%"> <stop offset="0%" style="stop-color:#230AC7;stop-opacity:1" /> <stop offset="100%" style="stop-color:#4A90E2;stop-opacity:1" /> </linearGradient> </defs> <rect width="270" height="54" fill="url(#grad)" rx="5"/> <text x="135" y="30" font-family="Arial, sans-serif" font-size="18" font-weight="bold" text-anchor="middle" fill="white"> CoolSymbol </text> <text x="135" y="45" font-family="Arial, sans-serif" font-size="10" text-anchor="middle" fill="#E0E0E0"> Symbols & Emojis </text> </svg>`; const svgDataUri = `data:image/svg+xml;base64,${Buffer.from(svgLogo).toString('base64')}`; console.log('\\nCreated optimized SVG logo (estimated size: ~1.2KB):'); console.log('Data URI length:', svgDataUri.length, 'bytes'); fs.writeFileSync('img/symbolsemoji-optimized.svg', svgLogo); return svgDataUri} console.log('Starting image compression optimization...'); optimizeImageCompression(); const svgOptimization = createOptimizedImagePlaceholder(); console.log('\\n✅ Image optimization setup complete!'); console.log('Next steps:'); console.log('1. Use online compressor to reduce WebP file size'); console.log('2. Apply CSS optimizations for better perceived performance'); console.log('3. Consider SVG alternative for even smaller file size'); (function(){'use strict'; const PerformanceAudit ={measureCoreWebVitals(){const results ={fcp: null, lcp: null, cls: null, fid: null, ttfb: null }; const paintEntries = performance.getEntriesByType('paint'); const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint'); if (fcpEntry){results.fcp = fcpEntry.startTime} const navigationEntry = performance.getEntriesByType('navigation')[0]; if (navigationEntry){results.ttfb = navigationEntry.responseStart - navigationEntry.requestStart} if ('PerformanceObserver' in window){try{const lcpObserver = new PerformanceObserver((list) =>{const entries = list.getEntries(); const lastEntry = entries[entries.length - 1]; results.lcp = lastEntry.startTime}); lcpObserver.observe({entryTypes: ['largest-contentful-paint'] })} catch (e){console.warn('LCP measurement not supported')} try{let clsValue = 0; const clsObserver = new PerformanceObserver((list) =>{for (const entry of list.getEntries()){if (!entry.hadRecentInput){clsValue += entry.value} } results.cls = clsValue}); clsObserver.observe({entryTypes: ['layout-shift'] })} catch (e){console.warn('CLS measurement not supported')} } return results}, analyzeResources(){const resources = performance.getEntriesByType('resource'); const analysis ={totalResources: resources.length, totalSize: 0, slowResources: [], largeResources: [], renderBlocking: [] }; resources.forEach(resource =>{const duration = resource.responseEnd - resource.requestStart; const size = resource.transferSize || 0; analysis.totalSize += size; if (duration > 1000){analysis.slowResources.push({name: resource.name, duration: Math.round(duration), size: Math.round(size / 1024) + 'KB' })} if (size > 100000){analysis.largeResources.push({name: resource.name, size: Math.round(size / 1024) + 'KB', duration: Math.round(duration) })} if (resource.renderBlockingStatus === 'blocking'){analysis.renderBlocking.push(resource.name)} }); return analysis}, checkOptimizations(){const checks ={criticalCSS: !!document.querySelector('style'), deferredJS: !!document.querySelector('script[defer]'), lazyLoading: !!document.querySelector('img[loading="lazy"]') || !!document.querySelector('img[data-src]'), compression: this.checkCompression(), caching: this.checkCaching(), minification: this.checkMinification() }; return checks}, checkCompression(){const resources = performance.getEntriesByType('resource'); let compressedCount = 0; resources.forEach(resource =>{if (resource.transferSize && resource.decodedBodySize){const compressionRatio = resource.transferSize / resource.decodedBodySize; if (compressionRatio < 0.8){compressedCount++} } }); return compressedCount > 0}, checkCaching(){const resources = performance.getEntriesByType('resource'); return resources.some(resource =>{return resource.name.includes('.css') || resource.name.includes('.js') || resource.name.includes('.png')})}, checkMinification(){const stylesheets = Array.from(document.querySelectorAll('link[rel="stylesheet"]')); const scripts = Array.from(document.querySelectorAll('script[src]')); const minifiedCSS = stylesheets.some(link => link.href.includes('.min.css')); const minifiedJS = scripts.some(script => script.src.includes('.min.js')); return minifiedCSS || minifiedJS}, generateReport(){const vitals = this.measureCoreWebVitals(); const resources = this.analyzeResources(); const optimizations = this.checkOptimizations(); const report ={timestamp: new Date().toISOString(), coreWebVitals: vitals, resourceAnalysis: resources, optimizations: optimizations, recommendations: this.getRecommendations(vitals, resources, optimizations) }; return report}, getRecommendations(vitals, resources, optimizations){const recommendations = []; if (vitals.fcp && vitals.fcp > 1800){recommendations.push('Consider further optimizing First Contentful Paint')} if (vitals.lcp && vitals.lcp > 2500){recommendations.push('Optimize Largest Contentful Paint - check for large images or slow resources')} if (vitals.cls && vitals.cls > 0.1){recommendations.push('Reduce Cumulative Layout Shift - add dimensions to images and reserve space for dynamic content')} if (resources.slowResources.length > 0){recommendations.push(`Optimize ${resources.slowResources.length} slow-loading resources`)} if (resources.largeResources.length > 0){recommendations.push(`Compress ${resources.largeResources.length} large resources`)} if (!optimizations.criticalCSS){recommendations.push('Implement critical CSS inlining')} if (!optimizations.deferredJS){recommendations.push('Defer non-critical JavaScript')} if (!optimizations.lazyLoading){recommendations.push('Implement lazy loading for images')} return recommendations}, displayResults(){const report = this.generateReport(); console.group('🚀 Performance Audit Results'); console.group('📊 Core Web Vitals'); console.log(`First Contentful Paint: ${report.coreWebVitals.fcp ? Math.round(report.coreWebVitals.fcp) + 'ms' : 'Measuring...'}`); console.log(`Largest Contentful Paint: ${report.coreWebVitals.lcp ? Math.round(report.coreWebVitals.lcp) + 'ms' : 'Measuring...'}`); console.log(`Cumulative Layout Shift: ${report.coreWebVitals.cls ? report.coreWebVitals.cls.toFixed(3) : 'Measuring...'}`); console.log(`Time to First Byte: ${report.coreWebVitals.ttfb ? Math.round(report.coreWebVitals.ttfb) + 'ms' : 'N/A'}`); console.groupEnd(); console.group('📦 Resource Analysis'); console.log(`Total Resources: ${report.resourceAnalysis.totalResources}`); console.log(`Total Size: ${Math.round(report.resourceAnalysis.totalSize / 1024)}KB`); console.log(`Slow Resources: ${report.resourceAnalysis.slowResources.length}`); console.log(`Large Resources: ${report.resourceAnalysis.largeResources.length}`); console.groupEnd(); console.group('✅ Optimizations'); Object.entries(report.optimizations).forEach(([key, value]) =>{console.log(`${key}: ${value ? '✅' : '❌'}`)}); console.groupEnd(); if (report.recommendations.length > 0){console.group('💡 Recommendations'); report.recommendations.forEach(rec => console.log(`• ${rec}`)); console.groupEnd()} console.groupEnd(); return report} }; if (document.readyState === 'complete'){setTimeout(() => PerformanceAudit.displayResults(), 1000)} else{window.addEventListener('load', () =>{setTimeout(() => PerformanceAudit.displayResults(), 1000)})} window.PerformanceAudit = PerformanceAudit; console.log('🔧 Performance Audit loaded. Run PerformanceAudit.displayResults() to see current metrics.')})(); const fs = require('fs'); function reduceBlockingTime(){const htmlFiles = fs.readdirSync('.').filter(file => file.endsWith('.html')); const optimizations = [{from: /<script>\s*\/\/ Advanced Reflow Prevention and DOM Optimization[\s\S]*?<\/script>/g, to: '<script src="dom-optimizer.js" async></script>' },{from: /<script src="script\.min\.js" async><\/script>\s*<script src="lazy-load\.js" async><\/script>\s*<script src="ad-blocker\.js" async><\/script>\s*<script src="performance-audit\.js" async><\/script>\s*<script src="treemap-analyzer\.js" async><\/script>\s*<script src="layout-shift-prevention\.js" defer><\/script>/g, to: `<script src="script.min.js" defer></script> <script> window.addEventListener('load', function(){const scripts = [ 'lazy-load.js', 'ad-blocker.js', 'performance-audit.js', 'treemap-analyzer.js', 'layout-shift-prevention.js' ]; scripts.forEach((src, index) =>{setTimeout(() =>{const script = document.createElement('script'); script.src = src; script.async = true; document.head.appendChild(script)}, index * 50)})}); </script>` } ]; let totalFixed = 0; htmlFiles.forEach(file =>{try{let content = fs.readFileSync(file, 'utf8'); let fileFixed = false; optimizations.forEach(opt =>{if (opt.from.test(content)){content = content.replace(opt.from, opt.to); fileFixed = true} }); if (fileFixed){fs.writeFileSync(file, content); console.log(`Reduced blocking time in: ${file}`); totalFixed++} } catch (error){console.error(`Error processing ${file}:`, error.message)} }); console.log(`\nBlocking time reduction complete! Fixed ${totalFixed} files.`); console.log('Scripts now load with reduced main thread blocking.')} function extractDOMOptimizer(){const domOptimizerContent = ` (function(){'use strict'; class DOMBatcher{constructor(){this.readQueue = []; this.writeQueue = []; this.scheduled = false; this.layoutCache = new WeakMap()} scheduleFlush(){if (!this.scheduled){this.scheduled = true; requestAnimationFrame(() => this.flushQueues())} } flushQueues(){this.readQueue.forEach(fn => fn()); this.readQueue = []; this.writeQueue.forEach(fn => fn()); this.writeQueue = []; this.scheduled = false} read(fn){this.readQueue.push(fn); this.scheduleFlush()} write(fn){this.writeQueue.push(fn); this.scheduleFlush()} getCachedLayout(element, property){if (!this.layoutCache.has(element)){this.layoutCache.set(element,{})} const cache = this.layoutCache.get(element); if (!(property in cache)){this.read(() =>{cache[property] = element[property]})} return cache[property]} clearCache(){this.layoutCache.clear()} } const domBatcher = new DOMBatcher(); const originalMethods ={}; ['offsetWidth', 'offsetHeight', 'clientWidth', 'clientHeight', 'scrollWidth', 'scrollHeight'].forEach(prop =>{Object.defineProperty(Element.prototype, '_' + prop,{get: function(){return domBatcher.getCachedLayout(this, prop)} })}); Element.prototype._getBoundingClientRect = function(){return domBatcher.getCachedLayout(this, 'boundingClientRect') || domBatcher.getCachedLayout(this, 'boundingClientRect', () => this.getBoundingClientRect())}; let resizeTimeout; window.addEventListener('resize', () =>{clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() =>{domBatcher.clearCache()}, 100)},{passive: true }); const visibilityObserver = new IntersectionObserver((entries) =>{entries.forEach(entry =>{if (entry.isIntersecting){entry.target.classList.add('visible')} else{entry.target.classList.remove('visible')} })},{rootMargin: '50px', threshold: 0.1 }); function observeElements(){document.querySelectorAll('.symbol, .maindata, .symbolTabel').forEach(el =>{visibilityObserver.observe(el)})} function init(){observeElements(); const style = document.createElement('style'); style.textContent = \` .symbol{contain: layout style paint; will-change: transform} .symbolTabel{contain: layout} .maindata{contain: layout style} .visible{transform: translateZ(0)} \`; document.head.appendChild(style)} window.DOMOptimizer ={batchRead: (fn) => domBatcher.read(fn), batchWrite: (fn) => domBatcher.write(fn), clearCache: () => domBatcher.clearCache(), observeElement: (el) => visibilityObserver.observe(el) }; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', init)} else{init()} })();`; try{fs.writeFileSync('dom-optimizer.js', domOptimizerContent); console.log('Created dom-optimizer.js file')} catch (error){console.error('Error creating dom-optimizer.js:', error.message)} } extractDOMOptimizer(); reduceBlockingTime(); (function(){'use strict'; class DOMBatcher{constructor(){this.readQueue = []; this.writeQueue = []; this.scheduled = false; this.layoutCache = new WeakMap()} scheduleFlush(){if (!this.scheduled){this.scheduled = true; requestAnimationFrame(() => this.flushQueues())} } flushQueues(){this.readQueue.forEach(fn => fn()); this.readQueue = []; this.writeQueue.forEach(fn => fn()); this.writeQueue = []; this.scheduled = false} read(fn){this.readQueue.push(fn); this.scheduleFlush()} write(fn){this.writeQueue.push(fn); this.scheduleFlush()} getCachedLayout(element, property){if (!this.layoutCache.has(element)){this.layoutCache.set(element,{})} const cache = this.layoutCache.get(element); if (!(property in cache)){this.read(() =>{cache[property] = element[property]})} return cache[property]} clearCache(){this.layoutCache.clear()} } const domBatcher = new DOMBatcher(); const originalMethods ={}; ['offsetWidth', 'offsetHeight', 'clientWidth', 'clientHeight', 'scrollWidth', 'scrollHeight'].forEach(prop =>{Object.defineProperty(Element.prototype, '_' + prop,{get: function(){return domBatcher.getCachedLayout(this, prop)} })}); Element.prototype._getBoundingClientRect = function(){return domBatcher.getCachedLayout(this, 'boundingClientRect') || domBatcher.getCachedLayout(this, 'boundingClientRect', () => this.getBoundingClientRect())}; let resizeTimeout; window.addEventListener('resize', () =>{clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() =>{domBatcher.clearCache()}, 100)},{passive: true }); const visibilityObserver = new IntersectionObserver((entries) =>{entries.forEach(entry =>{if (entry.isIntersecting){entry.target.classList.add('visible')} else{entry.target.classList.remove('visible')} })},{rootMargin: '50px', threshold: 0.1 }); function observeElements(){document.querySelectorAll('.symbol, .maindata, .symbolTabel').forEach(el =>{visibilityObserver.observe(el)})} function init(){observeElements(); const style = document.createElement('style'); style.textContent = ` .symbol{contain: layout style paint; will-change: transform} .symbolTabel{contain: layout} .maindata{contain: layout style} .visible{transform: translateZ(0)} `; document.head.appendChild(style)} window.DOMOptimizer ={batchRead: (fn) => domBatcher.read(fn), batchWrite: (fn) => domBatcher.write(fn), clearCache: () => domBatcher.clearCache(), observeElement: (el) => visibilityObserver.observe(el) }; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', init)} else{init()} })(); (function(){'use strict'; const TreemapAnalyzer ={collectResourceData(){const resources = performance.getEntriesByType('resource'); const bundleData ={timestamp: new Date().toISOString(), url: window.location.href, resources: [], summary:{totalSize: 0, totalTransferSize: 0, resourceCount: 0, categories:{} } }; resources.forEach(resource =>{const resourceInfo ={name: resource.name, type: this.getResourceType(resource.name), size: resource.decodedBodySize || 0, transferSize: resource.transferSize || 0, duration: Math.round(resource.responseEnd - resource.requestStart), cached: resource.transferSize === 0, compressed: resource.transferSize < resource.decodedBodySize }; bundleData.resources.push(resourceInfo); bundleData.summary.totalSize += resourceInfo.size; bundleData.summary.totalTransferSize += resourceInfo.transferSize; bundleData.summary.resourceCount++; const category = resourceInfo.type; if (!bundleData.summary.categories[category]){bundleData.summary.categories[category] ={count: 0, size: 0, transferSize: 0 }} bundleData.summary.categories[category].count++; bundleData.summary.categories[category].size += resourceInfo.size; bundleData.summary.categories[category].transferSize += resourceInfo.transferSize}); return bundleData}, getResourceType(url){if (url.includes('.css')) return 'CSS'; if (url.includes('.js')) return 'JavaScript'; if (url.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/i)) return 'Images'; if (url.match(/\.(woff|woff2|ttf|eot)$/i)) return 'Fonts'; if (url.includes('.html')) return 'HTML'; return 'Other'}, generateTreemapData(){const data = this.collectResourceData(); const treemapData ={lhr:{audits:{'script-treemap-data':{details:{nodes: data.resources.map((resource, index) => ({name: resource.name.split('/').pop() || resource.name, resourceBytes: resource.size, unusedBytes: Math.max(0, resource.size - resource.transferSize), duplicate: false })) } } } }, artifacts:{URL:{finalUrl: window.location.href } } }; return treemapData}, displayAnalysis(){const data = this.collectResourceData(); console.group('📦 Bundle Size Analysis'); console.group('📊 Summary'); console.log(`Total Resources: ${data.summary.resourceCount}`); console.log(`Total Size: ${this.formatBytes(data.summary.totalSize)}`); console.log(`Transfer Size: ${this.formatBytes(data.summary.totalTransferSize)}`); console.log(`Compression Ratio: ${((1 - data.summary.totalTransferSize / data.summary.totalSize) * 100).toFixed(1)}%`); console.groupEnd(); console.group('📂 By Category'); Object.entries(data.summary.categories).forEach(([category, stats]) =>{console.log(`${category}: ${stats.count} files, ${this.formatBytes(stats.size)} (${this.formatBytes(stats.transferSize)} transferred)`)}); console.groupEnd(); console.group('🔍 Largest Resources'); const largestResources = data.resources .sort((a, b) => b.size - a.size) .slice(0, 10); largestResources.forEach(resource =>{console.log(`${resource.name.split('/').pop()}: ${this.formatBytes(resource.size)} (${resource.type})`)}); console.groupEnd(); console.group('🐌 Slowest Resources'); const slowestResources = data.resources .sort((a, b) => b.duration - a.duration) .slice(0, 10); slowestResources.forEach(resource =>{console.log(`${resource.name.split('/').pop()}: ${resource.duration}ms (${this.formatBytes(resource.size)})`)}); console.groupEnd(); console.groupEnd(); return data}, formatBytes(bytes){if (bytes === 0) return '0 B'; const k = 1024; const sizes = ['B', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]}, generateTreemapInstructions(){const instructions = ` 🌳 Lighthouse Treemap Analysis Instructions: 1. Run Lighthouse audit on this page: - Open Chrome DevTools (F12) - Go to Lighthouse tab - Check "Performance" and run audit 2. After audit completes: - Look for "View Treemap" button in the results - Or manually go to: https: 3. Upload your Lighthouse JSON report to the treemap tool 4. Alternative method: - Copy the data below and save as lighthouse-report.json - Upload to treemap tool Current bundle analysis:`; console.log(instructions); const treemapData = this.generateTreemapData(); console.log('Treemap Data (save as lighthouse-report.json):'); console.log(JSON.stringify(treemapData, null, 2)); return treemapData}, getOptimizationSuggestions(){const data = this.collectResourceData(); const suggestions = []; const largeResources = data.resources.filter(r => r.size > 100000); if (largeResources.length > 0){suggestions.push(`📦 ${largeResources.length} large resources (>100KB) found - consider code splitting or compression`)} const uncompressed = data.resources.filter(r => !r.compressed && r.size > 10000); if (uncompressed.length > 0){suggestions.push(`🗜️ ${uncompressed.length} uncompressed resources found - enable gzip/brotli compression`)} const resourceNames = data.resources.map(r => r.name.split('/').pop()); const duplicates = resourceNames.filter((name, index) => resourceNames.indexOf(name) !== index); if (duplicates.length > 0){suggestions.push(`🔄 ${duplicates.length} potential duplicate resources found`)} const jsSize = data.summary.categories.JavaScript?.size || 0; if (jsSize > 500000){suggestions.push(`📜 JavaScript bundle is ${this.formatBytes(jsSize)} - consider code splitting`)} const cssSize = data.summary.categories.CSS?.size || 0; if (cssSize > 200000){suggestions.push(`🎨 CSS bundle is ${this.formatBytes(cssSize)} - consider critical CSS extraction`)} return suggestions} }; if (document.readyState === 'complete'){setTimeout(() =>{TreemapAnalyzer.displayAnalysis(); const suggestions = TreemapAnalyzer.getOptimizationSuggestions(); if (suggestions.length > 0){console.group('💡 Optimization Suggestions'); suggestions.forEach(suggestion => console.log(suggestion)); console.groupEnd()} }, 2000)} else{window.addEventListener('load', () =>{setTimeout(() =>{TreemapAnalyzer.displayAnalysis(); const suggestions = TreemapAnalyzer.getOptimizationSuggestions(); if (suggestions.length > 0){console.group('💡 Optimization Suggestions'); suggestions.forEach(suggestion => console.log(suggestion)); console.groupEnd()} }, 2000)})} window.TreemapAnalyzer = TreemapAnalyzer; console.log('🌳 Treemap Analyzer loaded. Use TreemapAnalyzer.generateTreemapInstructions() for Lighthouse treemap setup.')})(); (function(){'use strict'; const startTime = performance.now(); const deferAllScripts = () =>{const scripts = document.querySelectorAll('script[src]'); scripts.forEach(script =>{if (!script.src.includes('critical') && !script.src.includes('ultra')){script.remove(); window.addEventListener('load', () =>{const newScript = document.createElement('script'); newScript.src = script.src; newScript.defer = true; newScript.async = true; document.head.appendChild(newScript)},{once: true })} })}; const injectCriticalCSS = () =>{const criticalCSS = ` *{box-sizing:border-box;margin:0;padding:0} body{font:16px/1.4 system-ui,-apple-system,sans-serif;background:#ebecef;margin:0} header{width:100%;background:#230AC7;height:60px;contain:strict} .headCont{max-width:1168px;margin:0 auto;text-align:center;height:60px} .mainlogo{width:100%;background:#230AC7;color:#fff;padding:5px 0;height:50px;contain:strict} .mainlogo img{width:270px;height:50px;aspect-ratio:270/50;display:block;margin:0 auto} .symbol{text-align:center;margin:0 0 0.5rem 0.1rem;border:1px solid #d3d3d3;display:inline-block;width:50px;height:50px;font-size:30px;line-height:50px;cursor:pointer;contain:strict;transform:translateZ(0)} .symbol:hover{background:#ececec;transform:translateY(-2px)} .maindata{min-height:400px;contain:strict;display:block;visibility:visible} .footer{height:80px;contain:strict} img{image-rendering:optimizeSpeed;image-rendering:-webkit-optimize-contrast} `; const style = document.createElement('style'); style.textContent = criticalCSS; document.head.insertBefore(style, document.head.firstChild)}; const eliminateLayoutShift = () =>{const allocateDimensions = () =>{const logoImg = document.querySelector('.mainlogo img'); if (logoImg){logoImg.width = 270; logoImg.height = 50; logoImg.style.cssText = 'width:270px;height:50px;aspect-ratio:270/50;display:block;margin:0 auto'} document.querySelectorAll('.symbol').forEach(symbol =>{symbol.style.cssText = 'width:50px;height:50px;min-width:50px;min-height:50px;display:inline-block;contain:strict'}); const maindata = document.querySelector('.maindata'); if (maindata){maindata.style.cssText = 'min-height:400px;contain:strict;display:block;visibility:visible'} const footer = document.querySelector('.footer'); if (footer){footer.style.cssText = 'height:80px;contain:strict'} }; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', allocateDimensions)} else{allocateDimensions()} }; const preloadCriticalResources = () =>{const resources = [{href: 'main.css', as: 'style', importance: 'high' },{href: 'main.min.css', as: 'style', importance: 'high' },{href: 'img/symbolsemoji.com.webp', as: 'image', importance: 'high' } ]; resources.forEach(resource =>{const link = document.createElement('link'); link.rel = 'preload'; link.href = resource.href; link.as = resource.as; if (resource.importance) link.importance = resource.importance; if (resource.as === 'style'){link.onload = function(){this.rel = 'stylesheet'; this.media = 'all'}} document.head.appendChild(link)})}; const optimizeFonts = () =>{const preconnects = [ 'https: 'https: ]; preconnects.forEach(url =>{const link = document.createElement('link'); link.rel = 'preconnect'; link.href = url; if (url.includes('gstatic')) link.crossOrigin = 'anonymous'; document.head.appendChild(link)}); const fontStyle = document.createElement('style'); fontStyle.textContent = ` @font-face{font-display: swap} *{font-display: swap !important} body{font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif} `; document.head.appendChild(fontStyle)}; const progressiveSymbolLoad = () =>{const loadSymbols = () =>{const symbols = document.querySelectorAll('.symbol'); symbols.forEach((symbol, index) =>{if (index < 20){symbol.style.visibility = 'visible'; symbol.style.display = 'inline-block'} else{symbol.style.contentVisibility = 'auto'; symbol.style.containIntrinsicSize = '50px 50px'; if ('IntersectionObserver' in window){const observer = new IntersectionObserver((entries) =>{entries.forEach(entry =>{if (entry.isIntersecting){entry.target.style.visibility = 'visible'; entry.target.style.display = 'inline-block'; observer.unobserve(entry.target)} })},{rootMargin: '100px' }); observer.observe(symbol)} } })}; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', loadSymbols)} else{loadSymbols()} }; const optimizeImages = () =>{const optimizeImg = () =>{document.querySelectorAll('img').forEach(img =>{if (!img.loading) img.loading = 'lazy'; if (!img.decoding) img.decoding = 'async'; if (!img.width && !img.height){if (img.classList.contains('mainlogo') || img.closest('.mainlogo')){img.width = 270; img.height = 50} else{img.width = 50; img.height = 50} } img.style.imageRendering = 'optimizeSpeed'})}; if (document.readyState === 'loading'){document.addEventListener('DOMContentLoaded', optimizeImg)} else{optimizeImg()} }; const optimizeCSS = () =>{document.querySelectorAll('link[rel="stylesheet"]').forEach(link =>{if (!link.media || link.media === 'all'){link.media = 'print'; link.onload = function(){this.media = 'all'}} })}; const scheduleTask = (task, priority = 'background') =>{if ('scheduler' in window && 'postTask' in window.scheduler){window.scheduler.postTask(task,{priority })} else{requestIdleCallback ? requestIdleCallback(task) : setTimeout(task, 0)} }; const monitorPerformance = () =>{if ('PerformanceObserver' in window){const observer = new PerformanceObserver((list) =>{list.getEntries().forEach(entry =>{switch (entry.entryType){case 'largest-contentful-paint': console.log(`LCP: ${entry.startTime}ms`); break; case 'layout-shift': if (!entry.hadRecentInput){console.log(`CLS: ${entry.value}`)} break; case 'paint': if (entry.name === 'first-contentful-paint'){console.log(`FCP: ${entry.startTime}ms`)} break} })}); observer.observe({entryTypes: ['largest-contentful-paint', 'layout-shift', 'paint'] })} }; injectCriticalCSS(); deferAllScripts(); eliminateLayoutShift(); preloadCriticalResources(); optimizeFonts(); progressiveSymbolLoad(); optimizeImages(); scheduleTask(optimizeCSS); scheduleTask(monitorPerformance); console.log(`Ultra Performance Optimizer loaded in ${performance.now() - startTime}ms`)})(); const fs = require('fs'); const path = require('path'); const oldGACode = `<script async src="https: <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments)} gtag('js', new Date()); gtag('config', 'G-NP21SYTW1D'); </script>`; const newGACode = `<!-- Google tag (gtag.js) --> <script async src="https: <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments)} gtag('js', new Date()); gtag('config', 'G-NP21SYTW1D'); </script>`; async function updateGACode(){try{const files = await getAllFiles(path.join(__dirname)); const htmlFiles = files.filter(file => file.endsWith('.html')); console.log(`Found ${htmlFiles.length} HTML files to process.`); let updatedCount = 0; let notFoundCount = 0; let errorCount = 0; for (const file of htmlFiles){try{let content = fs.readFileSync(file, 'utf8'); if (content.includes('gtag/js?id=G-NP21SYTW1D')){const newContent = content.replace( /<script async[\s\S]*?gtag\('config', 'G-NP21SYTW1D'\);[\s\s]*?<\/script>/, newGACode ); fs.writeFileSync(file, newContent, 'utf8'); console.log(`Updated GA code in ${file}`); updatedCount++} else{console.log(`GA code not found in ${file}`); notFoundCount++} } catch (error){console.error(`Error processing ${file}:`, error.message); errorCount++} } console.log('\nUpdate complete!'); console.log(`Total files processed: ${htmlFiles.length}`); console.log(`Files updated: ${updatedCount}`); console.log(`Files without GA code: ${notFoundCount}`); console.log(`Errors: ${errorCount}`)} catch (error){console.error('Error:', error.message)} } function getAllFiles(dir, fileList = []){const files = fs.readdirSync(dir); files.forEach(file =>{const filePath = path.join(dir, file); const stat = fs.statSync(filePath); if (stat.isDirectory()){getAllFiles(filePath, fileList)} else if (path.extname(filePath).toLowerCase() === '.html'){fileList.push(filePath)} }); return fileList} updateGACode(); const fs = require('fs'); const path = require('path'); const oldTrackingId = 'G-NP21SYTW1D'; const newTrackingId = 'G-M7MH3WM8'; async function updateGATrackingId(){try{const files = await getAllFiles(path.join(__dirname)); const htmlFiles = files.filter(file => file.endsWith('.html')); console.log(`Found ${htmlFiles.length} HTML files to process.`); let updatedCount = 0; let notFoundCount = 0; let errorCount = 0; for (const file of htmlFiles){try{let content = fs.readFileSync(file, 'utf8'); if (content.includes(oldTrackingId)){const newContent = content.replace( new RegExp(oldTrackingId, 'g'), newTrackingId ); fs.writeFileSync(file, newContent, 'utf8'); console.log(`Updated GA tracking ID in ${file}`); updatedCount++} else{console.log(`GA tracking ID ${oldTrackingId} not found in ${file}`); notFoundCount++} } catch (error){console.error(`Error processing ${file}:`, error.message); errorCount++} } console.log('\nUpdate complete!'); console.log(`Total files processed: ${htmlFiles.length}`); console.log(`Files updated: ${updatedCount}`); console.log(`Files without old tracking ID: ${notFoundCount}`); console.log(`Errors: ${errorCount}`)} catch (error){console.error('Error:', error.message)} } function getAllFiles(dir, fileList = []){const files = fs.readdirSync(dir); files.forEach(file =>{const filePath = path.join(dir, file); const stat = fs.statSync(filePath); if (stat.isDirectory()){getAllFiles(filePath, fileList)} else if (path.extname(filePath).toLowerCase() === '.html'){fileList.push(filePath)} }); return fileList} updateGATrackingId();